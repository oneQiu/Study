# 直行便供应链

## 一面

### `TypeScript`里面的`infer`关键字

> `infer`关键字通常用来做类型推断，当我们需要从传入的类型中提取出某个子类型的时候使用，通常和泛型以及`extend`结合使用。

### 如何把联合类型转变为交叉类型

```typescript
type TypeA = {
  propA: string;
};

type TypeB = {
  propB: number;
};

type UnionType = TypeA | TypeB;

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;

type IntersectionType = UnionToIntersection<UnionType>;
```

### 函数式编程的优点

> 函数式编程是一种编程范式，主要的编程有命令式编程、声明式编程和函数式编程，相对于命令式编程，函数式编程更加强调程序的执行的结果而非过程，举个简单的栗子，对某个数组遍历添加1，如果是命名是编程就是一个`for`去操作，函数式编程就是`map`操作，只需要注重参数和结果导向。
> 代码简洁，提高可读性，便于多人协同开发，并且具有更好的复用性和组合能力。

### 函数柯里化

> 函数柯里化就是讲一个多参数的函数调用形式变化为单一参数的函数调用，它可以提高函数的复用性。表面上来看是把简单的问题复杂化了，但是带来的是更多的自由度。

### 介绍一下`useEffect`

> `useEffect`是`React`的一个`hooks`，它主要的功能实现一个类似类组件的生命周期或依赖更新回调的功能。它接收两个参数，第一个参数是调用函数，会在组件创建时或依赖更新时触发，并且返回一个函数，返回的函数会在组件销毁时执行，一般用来做一些收尾工作，比如事件监听，定时器任务的销毁。第二个参数是一个数组，用来放置需要更新的变量，变更更新触发执行函数。

### 如果`useEffect`不传第二个参数呢？

> 不传依赖参数的话，它会在每次更新时都会触发。

### 为什么会有函数式组件，优点是什么？

> 在以前的类组件都是继承于`React.Componet`，它内部实现了状态、生命周期等能力，具备了一个组件所需要的大部分功能，但是同样的它无法难以拆分和复用，例如我有一段逻辑可以多组件通用，在函数式组件里面就可以直接使用自定义`hooks`去实现。函数式组件可以依靠`hooks`实现类组件的功能，它更加的灵活简洁，更贴切`React`的设计理念（组合、共用抽象，单一责任）

### 状态管理工具的缺点

> 学习成本和维护成本，对于后期维护和重构来说是有额外的开发量的，并且对于小型项目来说偏重，如果没有较多的全局状态的话，`context`就已经能够满足了

# Tritium Research

## 一面

### 自我介绍

### 你的职业规划

> 目前已经接触了管理岗，如果有条件的还是希望能够继续，然后技术方向的话因为最近几年相对来说比较火的可能就是低代码和`web3`，低代码接触过了，它的局限性很大，并且其实它所需要的技术含量并不高，个人还是倾向于`web3`。

### `web3`的理解和认知，它的实践

> `web3`并非说是一种具体的技术，而是一个新的互联网思想理念，它建立在区块链上，为了实现去中心化、安全、透明的互联网世界，去中心化也是`web3`的核心理念，以此来实现更加开发、公平的平台环境。特点：去中心化、智能合约、加密保护、开放协议。

### 你如何管理你的团队

> 目前是一种三部曲的一个节奏，一、在任务开发前会进行对应任务的分割评估，迭代阶段性的历程设定，保证有阶段性的交付。二、沟通，保证开发有足够的时间和资源，避免长时间的压力导致低效率开发。三、自我提升，在每个迭代结束后都会有一些空档时间来给团队小伙伴一个自我提升的时间，注重团队建设。

### 团队人员数量，低代码项目多少人开发

> 开放题

### 介绍一下这个低代码平台

> 我所负责的这个低代码平台是以低代码为中心发散出的一系列生态，其中包含了低代码平台本身、物料库、谷歌插件、中台体系、`SDK`开发、审批流、RPA能力，后续规划中是加入物料市场、应用模板等一系列体系。

### 介绍一下低代码的核心要素

> 低代码的核心其实就是三要素，物料、画布、属性配置。
>
> 物料：物料的丰富程度决定了一个低代码的发展空间，物料的组合、功能封装、变量绑定、我们是基于`antd`以及`bizcharts`所封装的两套物料库区满足`SaaS`项目的使用。
>
> 画布：我所负责的低代码本身上是两套渲染方式，一套是`ali`等`lowcode-engine`，一套是自己所实现的，因为需要满足自定义画布的形式，画布所需要提供的不单单是渲染，还要暴露出各种钩子使用，譬如组件拖入后、容器接受到某些特殊组件钩子，这样才能覆盖多场景。
>
> 属性配置：这里其实就是将我们组件`Props`入参的可视化体现，对应的`meta`描述文件也是在物料库里面，通过解析`jsdoc`来自动生成。

### 子系统之间如何运转

> 以低代码项目为核心，平台本身包含了应用、页面构建等能力，中台系统来管理用户、角色、机构，物料库来维护物料、属性面板，`SDK`（即`flyfox-utils`）承担第三方平台使用的`API`能力提供，比如页面构建器、渲染器，谷歌插件是一套新的可视化模块功能。

### `DSL`的设计思路

> 1. 确定场景和目标：首先需要规划的就是`DSL`需要解决的场景和问题，我们是为了实现`Web RPA`能力，类似于一个脚本精灵
> 2. 定义语法规则：这一阶段就是去设计语法、关键字、表达式等一系列语言所需要的概念
> 3. 实现`DSL`解析和执行：我们参看`JS`的`AST`抽象语法树的形式，由自然语言对应的`JSON`结构转变为`JavaScript`代码，再去执行`JS`

### 自然语言的可视化的例子

> 例如`RPA`在页面上的一系列操作，点击页面，发起请求，滚动页面，在配置`RPA`操作的时候可视化的方式去配置，生成对应的`JSON`语法结构，再去有编译器去执行。

### 你认为的低代码是什么，它的局限性是什么

> 低代码是将各种所需的组件进行可视化展示自由组合，它会有两条路途，一种是无代码低代码形式，这就意味着需要高度封装能力，但是就是去了灵活性，如果要场景广泛，就必然失去了简便性。另外一种就是高定制化，可以由用户去定义页面结构、数据库、甚至每个字段信息，它能满足很多场景，但是就意味着搭建成本在此，就会衍生出一种软件实施的职能。

### 你如何去权衡低代码的灵活性和简便性

> 根据产品定位去抉择灵活性和简便性的取舍，你无法用有限的能力去实现无限的可能，即便是`alphaGo`也是采用的穷举法，如果定位的是`SaaS`向就要做高定制来提高简便性，定位是各种页面搭建，那就拓展物料的种类，牺牲简便性来换取灵活性。

### 如果说添加软件实施职能，它的成本和普通开发的成本怎么划分

> 一个软件实施员的成员其实不亚于一个前端开发的开销，目前我们的安排是平台用户免费使用搭建，如果说需要定制化某些功能，再去采取收费的形式去由软件实施员去完成，使用源码面板来完善，一方面是不在项目做特殊逻辑，一方面是以低成本为用户提供定制化开发服务。

### 如何破局解决低代码的局限性呢

> 1. 增强可拓展性和定制化，允许使用开发能力+自定义代码去解决受众面问题
> 2. 开发`API`和外部集成能力，比如物料市场一样，将平台压力分散出去
> 3. 数据模型可视化，将外界的`API`打通，去为已有系统只需要个别页面的需求做数据的流动
> 4. 结合`AI`能力，培养出一套模型使其能够代替软件实施员的大部分工作
>
> PS：总之就是平衡简化开发和满足复杂需求，通过提供拓展、自定义能力。从根源上来讲，低代码的设计如此，如果想要真正的破局可能需要做的是颠覆低代码的本质。

### 介绍一下你的组件库，主要有哪些功能

> 主要是三大部分，一部分是最初在设计初期针对表单以及`Table`数据渲染的能力封装，组件联动、异步数据源、数据格式转换、只读禁用状态，搜索栏、字段渲染等功能。另外一部分就是针对业务所总结的一些业务组件和交互组件，例如富文本编辑器、悬浮容器、选项卡抽屉等，最后就是工具函数和自定义`hooks`。

### 富文本编辑器所实现的功能

> 基于`TinyMce`实现，添加了劫持粘贴图片附件上传到`CDN`，展示远程地址，由此来解决模板`html`字符串过大问题，模板展示、替换功能，进行据模板配置，然后支持上传`word`类文件，再传入数据进行批量的字段替换，生成文档文件或者`html`代码。

### 你们组件库有实现按需加载吗

> 使用了`antd`的`babel-plugin-import`来实现，每个组件都独立模块，在用户使用的时候只导出某个组件，而组件库保证模块只使用那几个组件来保证。

### 版本更新是怎么去定义的

> 分为大小版本两种，一般在有很大的特性更新的时候，同时可能存在断代的可能性会采取大版本变更，小版本通常是日常的迭代，里面就是一些`debug`和`feature`。

### 遇到断代更新怎么办

> 1. 渐进式更新，提前版本预告属性遗弃
> 2. 文档说明
> 3. 第三方工具库做兼容

### 项目的开发流程

> 1. 需求评审，拆分任务需求
> 2. `devOps`平台分配需求
> 3. 建立迭代分支开发
> 4. 通过`CI/CD`自动化部署环境
> 5. 测试、`debug`、线上回归

### 事件循环机制

> 由于`JS`的特殊点，它初期是用来操作`dom`，为了避免交互冲突设计成了单线程非阻塞的编程语言，为此在对异步任务的时候它需要有一套自己的机制来应对异步任务来实现非阻塞。
>
> 在异步处理上采取了消息队列+事件循环，`JS`引擎会维护一个执行栈，这个执行栈是当前所执行的`JS`代码，`JS`中分为同步任务和异步任务两种，在遇到同步任务的时候会直接推入执行栈当中，而遇到异步任务的时候会将其交给对应的浏览器线程去执行，然后将回调函数放入对应的任务队列当中，待执行栈中的任务执行完以后，会优先去检查微任务队列是否清空，如果存在就推入执行栈清空，这个时间间隙会去检查是否需要进行渲染任务以及垃圾回收。最后`JS`引擎再去检查宏任务队列，从中取出。

### 异步编程的历史变化

> 回调函数 > `Promise` > `async await `
>
> 最初的回调函数作为参数传入到异步函数当中，但是当异步函数过多，就会出现回调地狱的问题，并且代码可读性很差。`ES6`加入了`Promise`语法，采用链式调用的形式解决了回调地狱的问题，提高代码的可读性，但是在过多的`then catch`方法其实也会有一种回调地狱的感觉。对此`async await`函数出现了，它真正的做到了将异步转为同步的编程感觉，通常`await`接受的是一个`Promise`，会等待它状态改变才会继续执行后续任务。

### `async`的底层实现

> `generator`函数和一个自执行器，能够自动在`Promise`状态改变的时候自动执行`yeid`。

### `Promise`的实现

> `Promise`有这么几个特点，状态不可变，成功失败的回调函数队列，执行后的一个新`Promise`返回。




# `JS`概念

## `JS`执行过程

1. 词法分析
2. 语法分析
3. 代码预解析：生成 GO、VO 对象（预解析）
4. 解释代码执行：逐行执行代码

### 词法解析

对代码进行词法分析，转换成词法单元（Token），例如`var x = 'QiuQiu';` 会被词法分析器分析为以下内容：

```json
[
	{
		"type": "Keyword",
		"value": "var"
	},
	{
		"type": "Indentifier",
		"value": "x"
	},
	{
		"type": "Punctuator",
		"value": "="
	},
	{
		"type": "Numeric",
		"value": "QiuQiu"
	},
	{
		"type": "Punctuator",
		"value": ";"
	}
]
```

PS：[词法解析](https://esprima.org/demo/parse.html#)

### 语法分析

语法分析阶段就会根据上面生成的 Token 转换成树状的抽象语法树`AST`

## 事件循环机制

> JavaScript 中的事件循环(Event Loop)通常被称为消息循环(Message Loop)。 它是 JavaScript 运行时的核心机制之一，用于解决异步任务的调用问题。
> 在 JavaScript 中，存在同步任务和异步任务，它们的执行顺序和方式不同。 同步任务会按照代码的顺序直接进入调用栈中执行，并在执行完毕后弹出栈。 而异步任务则会被放入对应的任务队列中等待执行，常见的异步任务包括定时器、网络请求、事件监听等。
> 在事件循环过程中，同步任务会直接进入调用栈并执行，而异步任务则会先被放入事件队列中等待执行。事件队列通常分为宏任务队列和微任务队列。宏任务队列包括 script 脚本、setTimeout、setInterval、I/O、UI 渲染等任务，不过在现在复杂等浏览器环境下面，宏任务被拆分了多个任务队列，任务没有优先级，但是任务队列存在优先级，在不同浏览器实现中会有不同的体现，因为现在并没有一个规范顺序。而微任务队列包括 Promise.then()、Promise.catch()、Promise.finally()、process.nextTick、MutationObserver 等任务。在事件循环的过程中，宏任务和微任务的执行顺序是不同的。当一个宏任务执行完成后，会先执行微任务队列中的所有任务，然后再从宏任务队列中取出下一个任务进行执行。这个过程不断重复，就形成了事件循环。消息队列是异步任务队列的一种实现方式，它主要用来存储异步任务的回调函数和其他事件。当异步任务完成时，将产生一个事件并将其对应的回调函数放入消息队列中。在 JavaScript 中，事件循环机制的作用是在主线程空闲时从消息队列中取出下一个任务并执行。当调用栈为空时，JavaScript 引擎会检查消息队列，如果队列中有任务，引擎就会将消息队列中的任务放入调用栈中执行。这个过程不断重复，就形成了事件循环。

渲染任务
渲染任务是独立于宏任务以及微任务的一个特殊任务，在宏任务处理完以后，会等待一段时间，这段时间进行垃圾回收，资源缓存，然后检查是否需要执行渲染任务，如果需要则进行渲染任务，否则进行下一个宏任务。

消息队列又是什么？
消息队列是异步队列的一个实现方式，它是用来储存异步任务的回调函数和其它事件，当异步任务完成的时候，将产生一个消息事件放入到消息队列当中。在`JavaScript`中，`Event Loop`会在执行栈空的时候去检查消息队列是否有任务，然后依次从列队当中取出并推入到执行栈当中执行，至到队空。

## 闭包

> 在我的理解里面，闭包就是利用`作用域链`和`垃圾回收机制`的特点，能够访问自由变量的函数，外部环境去访问内部的变量。

## 内存泄漏

> 当存在内存未使用且不会被垃圾回收机制所回收的时候，那就造成了内存泄漏

### 那些情况会造成内存泄漏

- 未清除的全局变量
- 闭包使用后未销毁
- 事件监听
- `setInterval`
- `console`

## 垃圾回收机制

> 为了保证`JS`在使用中不会出现内存溢出，定期找到无用的内存，然后释放。目前主要的垃圾回收机制主要为标记清除法和引用计数法

### 标记清除法（主要）

1. 初始化阶段会将进入执行环境的所有对象添加 tag
2. 为使用中的对象调整 tag 为使用中
3. 清楚 tag 为未使用状态的对象
4. 重置，等待下一次 GC

缺点：内存碎片化，导致内存分配速度变慢

### 引用计数法

> 引用计数机制会追踪每个值被引用的次数，每一段时间回去检索引用次数为 0 的对象同时清除它，但是它无法识别相互引用的问题。

## 原型和原型链

> `JS`里的每个对象都有一个原型属性`__proto__`（官方的获取方法是`Object.getPrototypeOf()`，它会指向构造函数的原型对象`Function.prototype`，而`prototype`上也存在一个构造器属性`constructor`指向构造函数本身。
> `prototype`是所有函数的拥有的原型对象。

## 作用域和作用域链

> 代码中定于变量的区域。在`JS`当中也叫做静态作用域
> 独立于执行栈

- 静态作用域/词法作用域：函数的作用于在定义的时候就确定下来了
- 动态作用域：函数在调用的时候确定的

### 执行上下文

### 执行代码

- 全局代码
- 函数代码
- `eval`

如果代码没有通过`var`去定义，那么就不会被`AO`所收集

### 执行上下文栈

## 继承

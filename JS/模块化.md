# 前端模块化

## 前言

### 什么是模块化？

模块化即将一个复杂的程序按照一定的规范拆分成不同的块，提高可复用性以及模块管理，复杂的东西简单化。

### 解决哪些问题？

- 全局命名冲突：早期的`JS`代码基本都是在全局挂载变量，但是随着项目的不断开拓，总会出现一些命名冲突问题。
- 复用性差：这就涉及到另外一个概念，面向过程开发和面向对象开发，模块化开发的前提即面向对象开发，能够通用的解决一系列的问题或者实现功能
- 并行开发：采用模块化开发以后，可以多人协同开发，自己关注所负责的模块即可，提高协同开发效率。
- 依赖关系：以前的`JS`都是直接在页面添加`script`标签，肉眼很难分辨依赖的先后次序。

### 模块化之前

在模块化方案出来之前，其实在开发的时候就已经有一些模块化开发的影子了，就比如采用命名空间、闭包等方式去实现，但是依然存在命名冲突的问题。

#### 命名空间

```javascript
将整个模块挂在某个变量上，但是会被外界所修改，也存在命名冲突问题。
let moduleA = {
	name: 'A',
	run() {
		/// ...功能
		return this.name;
	},
};
```

#### 闭包 `IIFE`立即执行函数

通常会把模块挂在某个变量上，同时无法直接操作内部变量，只能通过暴露的方法去修改，典型的就是`jquery`的`$`。

```javascript
((window) => {
	let a = '123';
	function setName(name) {
		a = name;
	}
	window.moduleB = { a, setName };
})();
```

## 模块化方案

目前比较常用的几种模块化开发方案：

### `CommonJS`

> 比较常见的就是在`Node`环境上，遵循一个文件就是一个模块，每个文件都有各自的作用域，文件内的变量方法皆为私有。

#### 特点

- 加载机制：在服务端中`CommonJS`是采用同步加载的方式，而浏览器端需要提前编译打包代码。
- 模块作用域：所有模块都具有模块作用域，不会污染全局作用域。
- 缓存：在首次加载的时候就会被缓存下来，后续再引用其实是用的都是缓存。
- 加载顺序：根据`require`的顺序进行依赖。

#### 语法

```javascript
// 导入
const a = require('a'); // 实际上加载的是modules.exports的浅拷贝对象
// 导出
module.exports = {};
```

### `AMD`

因为`CommonJS`的同步加载机制，所以浏览器端并不是用该方案，因为模块都在服务端，如果同步加载就会导致出现假死状态，所以`AMD`出现了，异步模块化方案。
不过`AMD`并没直接支持的，需要依赖库，例如`RequireJS`。

#### 特点

- 异步加载模块
- 回调函数形式执行

#### 语法

```javascript
// 导入
require(['A', 'B'], (a, b) => {
	// cb
});
// 定义无依赖模块
define(() => {
	return {}; // 模块
});
// 定义有依赖模块
define(['A', 'B'], (a, b) => {
	return {};
});
```

### `UMD`

### `ES6`

#### 特点

- 编译时输出接口
- 输出的值的引用

#### 语法

使用`import`导入模块，默认导入的是`export default`所暴露的对象，而结构内的则是离散导出。

```javascript
import x, { a } from './x.js';
// 单独导出
export const b = 123;
// 默认导出
export default {};
```

- 实现`new`方法的功能

  > 首先我们需要明白`new`做了哪些事情：创建一个空对象，然后把空对象的原型对象`__proto__`指向构造函数的`protoype`上，同时将`this`指向绑定到该对象上。 [Demo](./JS/new.js)

  ```JavaScript
  function newFunc() {
    // 取出构造函数
    const constructor = [].shift.call(arguments);
    // 创建空对象的同时绑定原型对象
    const obj = Object.create(constructor.prototype);
    // 执行函数
    const result = constructor.apply(obj, arguments);
    return typeof result === 'object' ? result : obj;
  }
  ```

- 手写`apply`

  > `apply`类似于`call bind`，都是用作于绑定`this`指向，但是`apply`接收的参数是数组，同时它会立即执行当前函数，不想`bind`是返回一个绑定后的函数。[Demo](./JS/apply.js)

- 手写`instance of`
> `instance of`本质上是通过原型链上判断是否存在关系 [Demo]('./js/instanceOf.js')
```javascript
  function myInstanceOf(l, r) {
    const rProto = r.prototype;
    let tempProto = l.__proto__;
    while (true) {
        if (tempProto === null) return false;
        if (tempProto === rProto) return true;
        tempProto = tempProto.__proto__;
    }
}
```

# 面试常见手写代码



## `JavaScript`相关

### 实现`new`方法的功能

首先我们需要明白`new`做了哪些事情：

1. 创建一个空对象。
2. 把空对象的原型`__proto__`指向构造函数的`protoype`上。
3. 同时将`this`指向绑定到该对象上。
4. 如果构造函数返回了引用类型，则返回该值，否则返回这个对象。

```JavaScript
function newFunc() {
  // 取出构造函数
  const constructor = [].shift.call(arguments);
  // 判断是否是function
  if (typeof constructor !== 'function') {
      throw SyntaxError('constructor is not a function');
  }
  // 创建空对象的同时绑定原型对象
  const obj = Object.create(constructor.prototype);
  // 执行函数
  const result = constructor.apply(obj, arguments);
  return typeof result === 'object' ? result : obj;
}
```

### 手写`apply`

> `apply`类似于`call bind`，都是用作于绑定`this`指向，但是`apply`接收的参数是数组，同时它会立即执行当前函数，不想`bind`是返回一个绑定后的函数。

### 手写`instance of`

> `instance of`本质上是通过原型链上判断是否存在关系。
```javascript
  function myInstanceOf(l, r) {
    const rProto = r.prototype;
    let tempProto = l.__proto__;
    while (true) {
        if (tempProto === null) return false;
        if (tempProto === rProto) return true;
        tempProto = tempProto.__proto__;
    }
}
```

### 手写`Promise`

##### `Promise`有哪些特点？

- 状态不可变：当状态从`pending`转变为`fulfilled`或`rejected`以后则无法再变化。
- 错误捕获：`executor`内的函数如果出现错误，则会自动走向`rejeted`视角，且不会阻塞后续代码执行。
- 链式调用：可以通过`.then`或`.catch`执行后续操作，同时执行完`Promise`以后会再次返回一个新的`Promise`，后续的`.then`会收到上次的结果影响。
